{"version":3,"file":"popover-anchoring.service.d.ts","sources":["popover-anchoring.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { ElementRef, NgZone, OnDestroy, ViewContainerRef } from '@angular/core';\nimport { Overlay, OverlayRef } from '@angular/cdk/overlay';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { Subject } from 'rxjs';\nimport { SatPopover } from './popover.component';\nimport { SatPopoverOpenOptions } from './types';\nexport declare class SatPopoverAnchoringService implements OnDestroy {\n    private _overlay;\n    private _ngZone;\n    private _dir;\n    /** Emits when the popover is opened. */\n    popoverOpened: Subject<void>;\n    /** Emits when the popover is closed. */\n    popoverClosed: Subject<void>;\n    /** Reference to the overlay containing the popover component. */\n    _overlayRef: OverlayRef;\n    /** Reference to the target popover. */\n    private _popover;\n    /** Reference to the view container for the popover template. */\n    private _viewContainerRef;\n    /** Reference to the anchor element. */\n    private _anchor;\n    /** Reference to a template portal where the overlay will be attached. */\n    private _portal;\n    /** Single subscription to notifications service events. */\n    private _notificationsSubscription;\n    /** Single subscription to position changes. */\n    private _positionChangeSubscription;\n    /** Whether the popover is presently open. */\n    private _popoverOpen;\n    /** Emits when the service is destroyed. */\n    private _onDestroy;\n    constructor(_overlay: Overlay, _ngZone: NgZone, _dir: Directionality);\n    ngOnDestroy(): void;\n    /** Anchor a popover instance to a view and connection element. */\n    anchor(popover: SatPopover, viewContainerRef: ViewContainerRef, anchor: ElementRef | HTMLElement): void;\n    /** Gets whether the popover is presently open. */\n    isPopoverOpen(): boolean;\n    /** Toggles the popover between the open and closed states. */\n    togglePopover(): void;\n    /** Opens the popover. */\n    openPopover(options?: SatPopoverOpenOptions): void;\n    /** Closes the popover. */\n    closePopover(value?: any): void;\n    /** TODO: implement when the overlay's position can be dynamically changed */\n    repositionPopover(): void;\n    /** TODO: when the overlay's position can be dynamically changed, do not destroy */\n    updatePopoverConfig(): void;\n    /** Realign the popover to the anchor. */\n    realignPopoverToAnchor(): void;\n    /** Get a reference to the anchor element. */\n    getAnchorElement(): HTMLElement;\n    /** Apply behavior properties on the popover based on the open options. */\n    private _applyOpenOptions;\n    /** Create an overlay to be attached to the portal. */\n    private _createOverlay;\n    /** Removes the popover from the DOM. Does NOT update open state. */\n    private _destroyPopover;\n    /**\n     * Destroys the popover immediately if it is closed, or waits until it\n     * has been closed to destroy it.\n     */\n    private _destroyPopoverOnceClosed;\n    /** Close popover when backdrop is clicked. */\n    private _subscribeToBackdrop;\n    /** Close popover when escape keydown event occurs. */\n    private _subscribeToEscape;\n    /** Set state back to closed when detached. */\n    private _subscribeToDetachments;\n    /** Save the opened state of the popover and emit. */\n    private _saveOpenedState;\n    /** Save the closed state of the popover and emit. */\n    private _saveClosedState;\n    /** Gets the text direction of the containing app. */\n    private _getDirection;\n    /** Create and return a config for creating the overlay. */\n    private _getOverlayConfig;\n    /**\n     * Listen to changes in the position of the overlay and set the correct alignment classes,\n     * ensuring that the animation origin is correct, even with a fallback position.\n     */\n    private _subscribeToPositionChanges;\n    /** Map a scroll strategy string type to an instance of a scroll strategy. */\n    private _getScrollStrategyInstance;\n    /** Create and return a position strategy based on config provided to the component instance. */\n    private _getPositionStrategy;\n    /** Get fallback positions based around target alignments. */\n    private _getFallbacks;\n}\n"]}